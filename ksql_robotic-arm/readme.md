# ksqlDB - Robotic Arm

## set up

### start up the infrastructure

Bring up the entire stack by running:

```
docker-compose up -d
```

### Open ksqlDB cli

```
docker exec -it ksqldb-cli ksql http://ksqldb-server:8088
```

### Configure it for this demo

run the following commands that allows to rerun the queries always from the beginning of the data streams. This is **not to use in production**! It is for debugging/educational purpose only.

```
SET 'auto.offset.reset' = 'earliest';
```

## Lab

Please refer to [continuous-analytics-examples/epl_robotic-arm/readme.md](https://github.com/quantiaconsulting/continuous-analytics-examples/tree/master/epl_robotic-arm).

### Recap 

>Suppose you want to monitor with a stream processing engine a group of robots used for picking and placing goods in an Industry 4.0 storehouse. Each robotic arm sends events reporting its status:

>* ready to pick the good,
* good grasped,
* moving the good,
* placing the good,
* moving without any good.

>Several Force-Sensing Resistors measure the stress levels of the robotic arm. If the stress level is between 0 and 6, the robot is safely operating. If it is between 7 and 8, a controller should raise a warning. If it is above 9, a controller should stop the robot.

### E1 (already solved)

>Propose how to model the streaming data generated by the robotic arms.

#### solution

```
CREATE STREAM RoboticArm_STREAM (id VARCHAR, status VARCHAR, stressLevel INT, ts VARCHAR)
  WITH (
  kafka_topic='RoboticArm_topic', 
  value_format='json', 
  partitions=1,
  timestamp='ts',
  timestamp_format='yyyy-MM-dd''T''HH:mm:ssZ');
```

The same portion of the stream we use in EPL.

```
INSERT INTO RoboticArm_STREAM (id, status, stressLevel, ts) VALUES ('1', 'goodGrasped',1 ,'2021-10-23T06:00:01+0200');
INSERT INTO RoboticArm_STREAM (id, status, stressLevel, ts) VALUES ('1', 'movingGood',7 ,'2021-10-23T06:00:02+0200');
INSERT INTO RoboticArm_STREAM (id, status, stressLevel, ts) VALUES ('2', 'ready',0 ,'2021-10-23T06:00:02+0200');
INSERT INTO RoboticArm_STREAM (id, status, stressLevel, ts) VALUES ('2', 'goodGrasped',5 ,'2021-10-23T06:00:03+0200');
INSERT INTO RoboticArm_STREAM (id, status, stressLevel, ts) VALUES ('2', 'movingGood',9 ,'2021-10-23T06:00:04+0200');
INSERT INTO RoboticArm_STREAM (id, status, stressLevel, ts) VALUES ('1', 'placingGood',3 ,'2021-10-23T06:00:09+0200');
INSERT INTO RoboticArm_STREAM (id, status, stressLevel, ts) VALUES ('2', 'placingGood',3 ,'2021-10-23T06:00:09+0200');
INSERT INTO RoboticArm_STREAM (id, status, stressLevel, ts) VALUES ('1', 'moving',2 ,'2021-10-23T06:00:13+0200');
INSERT INTO RoboticArm_STREAM (id, status, stressLevel, ts) VALUES ('2', 'moving',1 ,'2021-10-23T06:00:13+0200');
INSERT INTO RoboticArm_STREAM (id, status, stressLevel, ts) VALUES ('1', 'ready',0 ,'2021-10-23T06:00:16+0200');
INSERT INTO RoboticArm_STREAM (id, status, stressLevel, ts) VALUES ('2', 'ready',0 ,'2021-10-23T06:00:16+0200');
```

### E2

> Write a continuous query that emits the max stress for each arm.

#### Solution

```
SELECT ID, MAX(stresslevel) AS MAX_STRESS
FROM RoboticArm_STREAM
GROUP BY ID EMIT CHANGES;
```

### E3

> A continuous query that emits the average stress level between a pick (status==goodGrasped) and a place (status==placingGood).

iniziamo con una cosa più semplice
E3.1

per ora cercate di trovare un braccio in status moving seguito dallo stesso braccio in status placing e restituire lo stress level in status moving e lo stress level in status placing
Emanuele Della Valle
@emanueledellavalle
12:58

select M.id AS ID, (M.stresslevel + p.stresslevel)/2 as AVG_StressLvl
from RoboticArm_STREAM AS M JOIN
     RoboticArm_STREAM_CP AS P WITHIN 7 seconds 
     ON M.id = P.id
where 
M.status = 'movingGood' AND
P.status = 'placingGood' AND
P.ts > M.ts
EMIT CHANGES;

E3.2
Ora potete trovare un braccio in status goodGrasped sseguito dallo stesso braccio in status moving seguito dallo stesso braccio in status placing e restituire l'id del braccio e (stressLevelGoodGrasped+stressLevelMoving+stressLevelPlacing)/3 (che è la media degli stress level nei tre stati)

select M.id AS ID, (G.stresslevel + M.stresslevel + p.stresslevel)/3 as AVG_StressLvl
from RoboticArm_STREAM AS G JOIN
     RoboticArm_STREAM_CP AS M WITHIN 3 seconds
     ON G.id = M.id JOIN
     RoboticArm_STREAM_CP2 AS P WITHIN 7 seconds 
     ON M.id = P.id
where 
G.status = 'goodGrasped' AND
M.status = 'movingGood' AND
P.status = 'placingGood' AND
M.ts > G.ts AND
P.ts > M.ts
EMIT CHANGES;

per più informazioni sul multi-way join https://kafka-tutorials.confluent.io/multi-joins/ksql.html e https://docs.ksqldb.io/en/latest/developer-guide/joins/join-streams-and-tables/#n-way-joins

#### soffitta

```
CREATE STREAM RoboticArm_STREAM_CP AS SELECT * FROM RoboticArm_STREAM EMIT CHANGES;

CREATE STREAM E3_1 AS SELECT *
FROM RoboticArm_STREAM M
  JOIN RoboticArm_STREAM_CP P WITHIN 7 SECONDS
  ON M.id = P.id
 WHERE 
 M.status ='movingGood' AND
 P.status ='placingGood' AND 
  P.ts > M.ts 
 EMIT CHANGES;


SELECT P_id, P_ts, count(*) AS CNT
FROM E3_1 
GROUP BY P_id, P_ts 
EMIT changes;

SELECT *
FROM RoboticArm_STREAM M
  JOIN RoboticArm_STREAM_CP P WITHIN 1 SECONDS
  ON M.id = P.id
 WHERE 
 M.status ='movingGood' AND
 P.status ='placingGood' AND 
  P.ts > M.ts 
 EMIT CHANGES;

