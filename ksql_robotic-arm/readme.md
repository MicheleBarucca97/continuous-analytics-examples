# ksqlDB - Robotic Arm

## set up

### start up the infrastructure

Bring up the entire stack by running:

```
docker-compose up -d
```

### Open ksqlDB cli

```
docker exec -it ksqldb-cli ksql http://ksqldb-server:8088
```

### Configure it for this demo

run the following commands that allows to rerun the queries always from the beginning of the data streams. This is **not to use in production**! It is for debugging/educational purpose only.

```
SET 'auto.offset.reset' = 'earliest';
```

## Lab

Please refer to [continuous-analytics-examples/epl_robotic-arm/readme.md](https://github.com/quantiaconsulting/continuous-analytics-examples/tree/master/epl_robotic-arm).

### Recap 

>Suppose you want to monitor with a stream processing engine a group of robots used for picking and placing goods in an Industry 4.0 storehouse. Each robotic arm sends events reporting its status:

>* ready to pick the good,
* good grasped,
* moving the good,
* placing the good,
* moving without any good.

>Several Force-Sensing Resistors measure the stress levels of the robotic arm. If the stress level is between 0 and 6, the robot is safely operating. If it is between 7 and 8, a controller should raise a warning. If it is above 9, a controller should stop the robot.

### E1 (already solved)

>Propose how to model the streaming data generated by the robotic arms.

#### solution

```
CREATE STREAM RoboticArm_STREAM (id VARCHAR, status VARCHAR, stressLevel INT, ts VARCHAR)
  WITH (
  kafka_topic='RoboticArm_topic', 
  value_format='json', 
  partitions=1,
  timestamp='ts',
  timestamp_format='yyyy-MM-dd''T''HH:mm:ssZ');
```

The same portion of the stream we use in EPL.

```
INSERT INTO RoboticArm_STREAM (id, status, stressLevel, ts) VALUES ('1', 'goodGrasped',1 ,'2021-10-23T06:00:01+0200');
INSERT INTO RoboticArm_STREAM (id, status, stressLevel, ts) VALUES ('1', 'movingGood',7 ,'2021-10-23T06:00:02+0200');
INSERT INTO RoboticArm_STREAM (id, status, stressLevel, ts) VALUES ('2', 'ready',0 ,'2021-10-23T06:00:02+0200');
INSERT INTO RoboticArm_STREAM (id, status, stressLevel, ts) VALUES ('2', 'goodGrasped',5 ,'2021-10-23T06:00:03+0200');
INSERT INTO RoboticArm_STREAM (id, status, stressLevel, ts) VALUES ('2', 'movingGood',9 ,'2021-10-23T06:00:04+0200');
INSERT INTO RoboticArm_STREAM (id, status, stressLevel, ts) VALUES ('1', 'placingGood',3 ,'2021-10-23T06:00:09+0200');
INSERT INTO RoboticArm_STREAM (id, status, stressLevel, ts) VALUES ('2', 'placingGood',3 ,'2021-10-23T06:00:09+0200');
INSERT INTO RoboticArm_STREAM (id, status, stressLevel, ts) VALUES ('1', 'moving',2 ,'2021-10-23T06:00:13+0200');
INSERT INTO RoboticArm_STREAM (id, status, stressLevel, ts) VALUES ('2', 'moving',1 ,'2021-10-23T06:00:13+0200');
INSERT INTO RoboticArm_STREAM (id, status, stressLevel, ts) VALUES ('1', 'ready',0 ,'2021-10-23T06:00:16+0200');
INSERT INTO RoboticArm_STREAM (id, status, stressLevel, ts) VALUES ('2', 'ready',0 ,'2021-10-23T06:00:16+0200');
```

### E2

> Write a continuous query that emits the max stress for each arm.

#### Solution

```
SELECT ID, MAX(stresslevel) AS MAX_STRESS
FROM RoboticArm_STREAM
GROUP BY ID EMIT CHANGES;
```

### E3

> A continuous query that emits the average stress level between a pick (status==goodGrasped) and a place (status==placingGood).

ksqlDB does not support the EPL's operator `->` (that reads as followed by). As in the case of the [fire alarm](https://github.com/quantiaconsulting/continuous-analytics-examples/tree/master/ksql_firealarm), we need to use a stream-to-stream join.

As we discussed for [Spark Strutured Streaming](https://github.com/quantiaconsulting/continuous-analytics-examples/blob/master/sss_robotic-arm/notebooks/spark-structured-streaming-Lab.ipynb), this is an hard task and it is better to simplify it.

#### E3.1

> A continuous query that emits the events between **a moving** (status==movingGood) and a place (status==placingGood)

NOTE: no request to average and only two consecutive events

You may expect the following query (that includes a self-join of the RoboticArm_STREAM) to run.

```
select *
from RoboticArm_STREAM AS M 
     JOIN RoboticArm_STREAM AS P WITHIN 7 seconds 
     ON M.id = P.id 
EMIT CHANGES;
```

If you try to register the query above, the ksqlCLI answers with an error: `Can not join 'ROBOTICARM_STREAM' to 'ROBOTICARM_STREAM': self joins are not yet supported`. This is indeed a limitation of the underlying [kafka streams API](https://github.com/confluentinc/ksql/issues/2030).

The way out it is to duplicate the stream and the topic as follows:

```
CREATE STREAM RoboticArm_STREAM_CP AS SELECT * FROM RoboticArm_STREAM EMIT CHANGES;
```

so that the query above becomes:

```
select *
from RoboticArm_STREAM AS M 
     JOIN RoboticArm_STREAM_CP AS P WITHIN 7 seconds 
     ON M.id = P.id 
EMIT CHANGES;
```

#### E3.2

> A continuous query that emits the events between a **pick (status==goodGrasped)** and a place (status==placingGood)

NOTE: I'm adding one more type of event, good grasped that should appear before any moving

Let's duplicate once more the topic:

```
CREATE STREAM RoboticArm_STREAM_CP2 AS SELECT * FROM RoboticArm_STREAM EMIT CHANGES;
```

So that the query becomes:

```
select * 
from RoboticArm_STREAM AS G JOIN 
       RoboticArm_STREAM_CP AS M WITHIN 3 seconds 
       ON G.id = M.id 
     JOIN RoboticArm_STREAM_CP2 AS P WITHIN 7 seconds 
       ON M.id = P.id 
 where G.status = 'goodGrasped' AND M.status = 'movingGood' AND P.status = 'placingGood' 
       AND M.ts > G.ts AND P.ts > M.ts EMIT CHANGES;
```

#### E3.3

> A continuous query that emits the average stress level between a pick (status==goodGrasped) and a place (status==placingGood)

NOTE: the original question

```
select M.id AS ID, (G.stresslevel + M.stresslevel + p.stresslevel)/3 as AVG_StressLvl 
from RoboticArm_STREAM AS G JOIN 
       RoboticArm_STREAM_CP AS M WITHIN 3 seconds 
       ON G.id = M.id 
     JOIN RoboticArm_STREAM_CP2 AS P WITHIN 7 seconds 
       ON M.id = P.id 
 where G.status = 'goodGrasped' AND M.status = 'movingGood' AND P.status = 'placingGood' 
       AND M.ts > G.ts AND P.ts > M.ts EMIT CHANGES;
```

### E4

> A continuous query that returns the robotic arms that,
>	
>  * in less than 10 second,
>  * picked a good while safely operating,
>  * moved it while the controller was raising a warning, and
>  * placed it while safely operating again.

```
CREATE STREAM warning AS
select M.id AS ID, M.ts, g.ts, UNIX_TIMESTAMP(P.ts) - UNIX_TIMESTAMP(g.ts) AS diff
from RoboticArm_STREAM AS G JOIN 
		RoboticArm_STREAM_CP AS M WITHIN 10 seconds ON G.id = M.id JOIN
		RoboticArm_STREAM_CP2 AS P WITHIN 10 seconds ON M.id = P.id 
 where G.status = 'goodGrasped' AND G.stressLevel < 7 AND
       M.status = 'movingGood' AND M.stressLevel > 6 AND M.stressLevel < 9 AND
       P.status = 'placingGood' AND P.stressLevel < 7 AND
       M.ts > G.ts AND P.ts > M.ts AND
       UNIX_TIMESTAMP(P.ts) - UNIX_TIMESTAMP(g.ts) < 10*1000 
EMIT CHANGES;
```
NOTE: we imposed the constrain *in less than 10 second* using the condition `UNIX_TIMESTAMP(P.ts) - UNIX_TIMESTAMP(g.ts) < 10*1000 `


### E5

> A continuous query that monitors the results of the previous one (i.e., E4) and counts how many times each robotic arm is present in the stream over a window of 10 seconds updating the counting every 2 seconds.

```
SELECT id, count(*) as CNT, 
		TIMESTAMPTOSTRING(WINDOWSTART, 'yyy-MM-dd HH:mm:ssZ','UTC+2') as window_start,
		TIMESTAMPTOSTRING(WINDOWEND, 'yyy-MM-dd HH:mm:ssZ','UTC+2') as window_end
FROM warning WINDOW HOPPING (SIZE 10 SECONDS, ADVANCE BY 2 SECONDS)
GROUP BY ID
EMIT CHANGES;
```